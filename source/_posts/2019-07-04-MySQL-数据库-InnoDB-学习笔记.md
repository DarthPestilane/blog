---
title: MySQL 数据库 InnoDB 学习笔记
date: 2019-07-04 15:55:28
categories:
- 笔记
tags:
- mysql
- innodb
- lock
- transaction
- index
- database
---
记录最近对MySQL学习的一些总结。

<!-- more -->

# 索引

## 聚合索引

主键字段的索引就是聚合索引，索引中保存了整行记录的所有字段值

## 辅助索引

其他字段的索引就是辅助索引，辅助索引仅仅保存了记录行的主键值(id) 和当前索引的字段。

## 索引覆盖(覆盖索引)

一般来说，当执行 `select * from user where age = 10;` 时，如果 `age` 字段添加了 `B+TREE` 索引，
则 MySQL 会先通过辅助索引查找到记录的 id，再通过聚合索引最终查找到数据行各字段的值。
但如果查询语句中只去查询索引中包含的字段，查询时就只需通过辅助索引定位，拿到索引字段值后将结果返回即可，
不用再去查找聚合索引，这样就实现了索引覆盖。当然，如果查询语句中还同时包含主键字段 (id) ，那也同样可以实现索引覆盖。

## 索引建立的几大原则

1. 最左匹配

    索引会从where 语句开始，从左到右进行匹配，直到遇到范围查询 (>，<，!=，like，between) 时，匹配将会停止。
    在 `a = 1 and b = 2 and c > 3 and d = 4` 语句中，建立联合索引 (a, b, c, d)，此时 字段 d 是无法用到索引的，因为 c > 3 是范围查询，
    索引匹配到这里就停止了。如果将联合索引的顺序调整为 (a, b, d, c) 则可以用到索引，
    因为上述的 where 语句等效于 `a = 1 and b = 2 and d = 4 and c > 3` 这个顺序和索引一致，虽然有范围查询但那已经是最后一个条件了。
    我们不用手动去调整 where 中条件的顺序，MySQL 查询优化器会自动调整条件位置，以尽可能地使用索引。

2. = 之间可以乱序

    由于 MySQL 查询优化器会自动调整条件位置，以尽可能地使用索引，所以在有索引 (a, b, c) 的情况下，`a = 1 and c = 3 and b = 2` 这样的语句也是可以使用索引的。

3. 尽量选择区分度高的字段来添加索引

    区分度是指一个字段的值在记录中去重后的数量比上所有记录数量，表示这个字段值不重复的比例，即: `count(distinct('column')) / count(*)`，
    在sql中一般可以这样来查看: `select type, count(*) from t group by type`。区分度越高则需要索引匹配的次数就越少，查询就越快速。
    可以看出，表中主键的区分度固定为 1，而一些类型、状态等枚举字段将会在数据量逐渐增大情况下趋近与 0，这样的字段更适合添加 `Hash` 索引而不是 `B+TREE`。

4. 索引列不能参与计算，否则无法使用索引

    比如 `from_unixtime(created_at) = '2019-07-04 14:41:30'` 是不能使用 create_time 索引的，应换成这样: `created_at = unix_timestamp('2019-07-04 14:43:11')`

# 事务

## 术语概念

- 脏读 (Dirty Read):

    事务中的修改，即使没有提交，对其他事务也都是可见的。事务可以读取未提交的数据，这也被称作脏读。
    例: A事务begin --> B事务begin --> B事务update某行 --> A事务select该行，得到了更新后的结果

- 不可重复读 (Unrepeatable Read):

    事务中的修改提交后，其结果被其他事务所读取到。
    例: A事务begin --> B事务begin --> B事务update某行 -->B 事务commit --> A事务读取该行，得到了更新后的结果

- 幻读 (Phantom Read):

    所谓幻读，指的是当某个事务在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时，会产生幻行。
    例: A事务begin --> B事务begin --> B事务insert -->B 事务commit --> A事务select，得到了之前没有的数据
    解决方式: 加锁 (乐观锁 / 悲观锁)。InnoDB 存储引擎通过多版本并发控制（MVCC）解决了幻读的问题。

| 事务隔离级别                | 脏读 | 不可重复读 | 幻读 | 备注                                                            |
| --------------------------- | ---- | ---------- | ---- | --------------------------------------------------------------- |
| (未提交读) Read Uncommitted | y    | y          | y    | 性能好，但是会早成许多业务上的异常，一般不用                    |
| (已提交读) Read Committed   | n    | y          | y    | 可以避免脏读，但是会出现不可重复读                              |
| (可重复读) Repeatable Read  | n    | n          | y    | InnoDB 默认的隔离级别，实际上已经通过 Next-Key 锁机制避免了幻读 |
| (串行化) Serializable       | n    | n          | n    | 性能消耗太大，一般不用 (select 时也会加锁)                      |

## 不可重复读和幻读的区别

区别在于 `不可重复读` 是由 `update`, `delete` 操作造成，而 `幻读` 是由 `insert` 操作造成。
在 `Read Committed` 级别下，当执行sql读取到数据后，给这些记录加锁，让其他事务无法修改这些数据，
则实现了 `可重复读`。但是这种方法是无法阻止 `insert` 操作的，当事务A读取了数据，并修改了某些数据(加锁)，
事务B还是可以insert数据提交，这时A事务再次读取就会发现多出了之前没有的数据，这就是幻读，而且无法通过行锁来避免。

## 乐观锁和悲观锁

- 悲观锁

悲观锁是有数据库本身提供的，具有良好的排他性。
在悲观锁的情况下，为了保证事务的隔离性，就需要一致性锁定读。读取数据时加锁，其它事务无法修改这些数据。

- 乐观锁

相比悲观锁，乐观锁要宽松一些，通常是通过版本(version)记录机制来实现的。何谓数据版本？即为数据增加一个版本标识，
在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个 `version` 字段来实现 (MVCC)。
读数据时将 `version` 一起读取，更新时对 `version` +1，提交的时候，将提交的数据版本和数据库表对应记录的版本进行对比，如果提交数据的版本大于当前数据版本，则执行更新，否则认为是过期的数据，不更新。

## MVCC 在 InnoDB 中的实现

在 MySQL 的 InnoDB 中，会在每行数据后添加两个额外的隐藏值来实现 MVCC，其中一个记录这条数据何时被创建，另一个记录这条数据何时过期(或者被删除)。
在实际操作中，存储的并不是时间，而是事务版本号。每开始一个新事务，版本号就会 +1。

- `select` 时，只读取<=当前事务版本的数据
- `insert` / `update` / `delete` 时，更新数据的事务版本

MVCC 解决了幻读的问题，然而却并不能阻止其他事务对数据的 `insert`，任然会引发数据冲突。要解决这个问题，需要对数据上锁。

## 快照读与当前度

在 `Repeatalbe Read` 级别下，MySQL 通过 MVCC 实现了快照读 (snapshot read)，即事务中普通的 select 语句只能读取到当下版本的数据。
然而update 等操作却读取的是最新版本的数据，也就是当前读 (current read)。在 MVCC 中:

- 快照读: 普通的 select 语句，不会加锁
  - `select * from t1 ...`
- 当前读: 特殊的 `select` 语句和 `insert` / `update` / `delete` 语句，都会上锁
  - `select * from t1 where ... lock in share mode`
  - `select * from t2 where ... for update`
  - `insert into ...`
  - `update t1 set ...`
  - `delete from t1 ...`

## Next-Key锁

Next-Key 锁是行锁和 GAP 锁(间隙锁)的结合。在 `Repeatalbe Read` 级别中，如果执行了索引查询并上锁，则会一同锁住索引两侧的数据(按索引字段排序)。
事务A执行 `select * from user`，其中 age 字段存在索引，其结果为:

```sh
+----+--------+---------+---------+-----+
| id | name   | address | other   | age |
+----+--------+---------+---------+-----+
| 7  | name7  | chengdu | nothing | 7   |
| 13 | name13 | chengdu | nothing | 13  |
| 14 | name14 | chengdu | nothing | 14  |
+----+--------+---------+-------+-------+
```

这里假设 `age` 字段值在整个表中的排序为 `..., 7, 13, 14, ...`。
事务A接着执行 `select * from user where age = 13 lock in share mode` 对数据上锁，输出:

```sh
+----+--------+---------+---------+-----+
| id | name   | address | other   | age |
+----+--------+---------+---------+-----+
| 13 | name13 | chengdu | nothing | 13  |
+----+--------+---------+---------+-----+
```

这时事务B想要插入数据，执行 `insert into user values(0, 'name16', 'hxxi', 'woman', 'nothing', 12)`，此时操作会被阻塞。
如果将刚才插入语句中的 age 字段值修改为一个 >= 14 或者 < 7 的值，结果会怎么样呢？执行 `insert into user values(0, 'name16', 'hxxi', 'woman', 'nothing', 6)`，输出:

```sh
Query OK, 1 row affected
Time: 0.012s
```

这说明了事务A中的 `select * from user where age = 13 lock in share mode` 不仅锁住了满足条件的记录行，
也锁住了 `age >= 7` 和 `age < 14` 的记录，也就是区间 `[7, 14)`，这就是 Next-Key 锁的效果。
在上面例子里的 age 字段是有索引的，，这点非常重要，因为如果没有索引的话，Next-Key 锁的范围将会锁住整个表，
即便是 `insert into user values(0, 'name16', 'hxxi', 'woman', 'nothing', 6)` 也会被阻塞。

